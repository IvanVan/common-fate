// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package types

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/common-fate/common-fate/accesshandler/pkg/types"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for AccessRuleStatus.
const (
	AccessRuleStatusACTIVE   AccessRuleStatus = "ACTIVE"
	AccessRuleStatusARCHIVED AccessRuleStatus = "ARCHIVED"
)

// Defines values for AccessRuleTargetDetailArgumentsFormElement.
const (
	INPUT       AccessRuleTargetDetailArgumentsFormElement = "INPUT"
	MULTISELECT AccessRuleTargetDetailArgumentsFormElement = "MULTISELECT"
)

// Defines values for ApprovalMethod.
const (
	AUTOMATIC ApprovalMethod = "AUTOMATIC"
	REVIEWED  ApprovalMethod = "REVIEWED"
)

// Defines values for GrantStatus.
const (
	GrantStatusACTIVE  GrantStatus = "ACTIVE"
	GrantStatusERROR   GrantStatus = "ERROR"
	GrantStatusEXPIRED GrantStatus = "EXPIRED"
	GrantStatusPENDING GrantStatus = "PENDING"
	GrantStatusREVOKED GrantStatus = "REVOKED"
)

// Defines values for IdpStatus.
const (
	IdpStatusACTIVE   IdpStatus = "ACTIVE"
	IdpStatusARCHIVED IdpStatus = "ARCHIVED"
)

// Defines values for ProviderSetupStatus.
const (
	COMPLETE                       ProviderSetupStatus = "COMPLETE"
	INITIALCONFIGURATIONINPROGRESS ProviderSetupStatus = "INITIAL_CONFIGURATION_IN_PROGRESS"
	VALIDATING                     ProviderSetupStatus = "VALIDATING"
	VALIDATIONFAILED               ProviderSetupStatus = "VALIDATION_FAILED"
	VALIDATIONSUCEEDED             ProviderSetupStatus = "VALIDATION_SUCEEDED"
)

// Defines values for ProviderSetupDiagnosticLogLevel.
const (
	ProviderSetupDiagnosticLogLevelERROR   ProviderSetupDiagnosticLogLevel = "ERROR"
	ProviderSetupDiagnosticLogLevelINFO    ProviderSetupDiagnosticLogLevel = "INFO"
	ProviderSetupDiagnosticLogLevelWARNING ProviderSetupDiagnosticLogLevel = "WARNING"
)

// Defines values for ProviderSetupValidationStatus.
const (
	ProviderSetupValidationStatusERROR      ProviderSetupValidationStatus = "ERROR"
	ProviderSetupValidationStatusINPROGRESS ProviderSetupValidationStatus = "IN_PROGRESS"
	ProviderSetupValidationStatusPENDING    ProviderSetupValidationStatus = "PENDING"
	ProviderSetupValidationStatusSUCCESS    ProviderSetupValidationStatus = "SUCCESS"
)

// Defines values for RequestArgumentFormElement.
const (
	SELECT RequestArgumentFormElement = "SELECT"
)

// Defines values for RequestEventFromGrantStatus.
const (
	RequestEventFromGrantStatusACTIVE  RequestEventFromGrantStatus = "ACTIVE"
	RequestEventFromGrantStatusERROR   RequestEventFromGrantStatus = "ERROR"
	RequestEventFromGrantStatusEXPIRED RequestEventFromGrantStatus = "EXPIRED"
	RequestEventFromGrantStatusPENDING RequestEventFromGrantStatus = "PENDING"
	RequestEventFromGrantStatusREVOKED RequestEventFromGrantStatus = "REVOKED"
)

// Defines values for RequestEventToGrantStatus.
const (
	RequestEventToGrantStatusACTIVE  RequestEventToGrantStatus = "ACTIVE"
	RequestEventToGrantStatusERROR   RequestEventToGrantStatus = "ERROR"
	RequestEventToGrantStatusEXPIRED RequestEventToGrantStatus = "EXPIRED"
	RequestEventToGrantStatusPENDING RequestEventToGrantStatus = "PENDING"
	RequestEventToGrantStatusREVOKED RequestEventToGrantStatus = "REVOKED"
)

// Defines values for RequestStatus.
const (
	RequestStatusAPPROVED  RequestStatus = "APPROVED"
	RequestStatusCANCELLED RequestStatus = "CANCELLED"
	RequestStatusDECLINED  RequestStatus = "DECLINED"
	RequestStatusPENDING   RequestStatus = "PENDING"
)

// Defines values for ReviewDecision.
const (
	APPROVED ReviewDecision = "APPROVED"
	DECLINED ReviewDecision = "DECLINED"
)

// Access Rule contains information for an end user to make a request for access.
type AccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleDetail contains detailed information about a rule and is used in administrative apis.
type AccessRuleDetail struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups    []string           `json:"groups"`
	ID        string             `json:"id"`
	IsCurrent bool               `json:"isCurrent"`
	Metadata  AccessRuleMetadata `json:"metadata"`
	Name      string             `json:"name"`

	// The status of an Access Rule.
	Status AccessRuleStatus `json:"status"`

	// A detailed target for an access rule
	Target AccessRuleTargetDetail `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleMetadata defines model for AccessRuleMetadata.
type AccessRuleMetadata struct {
	CreatedAt     time.Time `json:"createdAt"`
	CreatedBy     string    `json:"createdBy"`
	UpdateMessage *string   `json:"updateMessage,omitempty"`
	UpdatedAt     time.Time `json:"updatedAt"`
	UpdatedBy     string    `json:"updatedBy"`
}

// The status of an Access Rule.
type AccessRuleStatus string

// A target for an access rule
type AccessRuleTarget struct {
	// Provider
	Provider Provider `json:"provider"`
}

// A detailed target for an access rule
type AccessRuleTargetDetail struct {
	// Provider
	Provider Provider                    `json:"provider"`
	With     AccessRuleTargetDetail_With `json:"with"`
}

// AccessRuleTargetDetail_With defines model for AccessRuleTargetDetail.With.
type AccessRuleTargetDetail_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// AccessRuleTargetDetailArguments defines model for AccessRuleTargetDetailArguments.
type AccessRuleTargetDetailArguments struct {
	FormElement AccessRuleTargetDetailArgumentsFormElement `json:"formElement"`
	Groupings   AccessRuleTargetDetailArguments_Groupings  `json:"groupings"`
	Values      []string                                   `json:"values"`
}

// AccessRuleTargetDetailArgumentsFormElement defines model for AccessRuleTargetDetailArguments.FormElement.
type AccessRuleTargetDetailArgumentsFormElement string

// AccessRuleTargetDetailArguments_Groupings defines model for AccessRuleTargetDetailArguments.Groupings.
type AccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// Describes whether a request has been approved automatically or from a review
type ApprovalMethod string

// Approver config for access rules
type ApproverConfig struct {
	Groups []string `json:"groups"`

	// The user IDs of the approvers for the request.
	Users []string `json:"users"`
}

// a request body for creating a Access Rule Target
type CreateAccessRuleTarget struct {
	ProviderId string                      `json:"providerId"`
	With       CreateAccessRuleTarget_With `json:"with"`
}

// CreateAccessRuleTarget_With defines model for CreateAccessRuleTarget.With.
type CreateAccessRuleTarget_With struct {
	AdditionalProperties map[string]CreateAccessRuleTargetDetailArguments `json:"-"`
}

// CreateAccessRuleTargetDetailArguments defines model for CreateAccessRuleTargetDetailArguments.
type CreateAccessRuleTargetDetailArguments struct {
	Groupings CreateAccessRuleTargetDetailArguments_Groupings `json:"groupings"`
	Values    []string                                        `json:"values"`
}

// CreateAccessRuleTargetDetailArguments_Groupings defines model for CreateAccessRuleTargetDetailArguments.Groupings.
type CreateAccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// CreateRequestWith defines model for CreateRequestWith.
type CreateRequestWith struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// CreateRequestWithSubRequest defines model for CreateRequestWithSubRequest.
type CreateRequestWithSubRequest = []CreateRequestWith

// Favorite defines model for Favorite.
type Favorite struct {
	Id     string `json:"id"`
	Name   string `json:"name"`
	RuleId string `json:"ruleId"`
}

// FavoriteDetail defines model for FavoriteDetail.
type FavoriteDetail struct {
	Id     string                      `json:"id"`
	Name   string                      `json:"name"`
	Reason *string                     `json:"reason,omitempty"`
	Timing RequestTiming               `json:"timing"`
	With   CreateRequestWithSubRequest `json:"with"`
}

// A temporary assignment of a user to a principal.
type Grant struct {
	// The end time of the grant.
	End time.Time `json:"end"`

	// The ID of the provider to grant access to.
	Provider string `json:"provider"`

	// The start time of the grant.
	Start time.Time `json:"start"`

	// The current state of the grant.
	Status GrantStatus `json:"status"`

	// The email address of the user to grant access to.
	Subject openapi_types.Email `json:"subject"`
}

// The current state of the grant.
type GrantStatus string

// Group defines model for Group.
type Group struct {
	Description string   `json:"description"`
	Id          string   `json:"id"`
	MemberCount int      `json:"memberCount"`
	Members     []string `json:"members"`
	Name        string   `json:"name"`
	Source      string   `json:"source"`
}

// IdpStatus defines model for IdpStatus.
type IdpStatus string

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// A matched access rule with option values if they are required for the access rule request
type LookupAccessRule struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// If the matched access rule has selectable fields, this array will contain the matched values to be used to prefill the form when requesting
	SelectableWithOptionValues *[]KeyValue `json:"selectableWithOptionValues,omitempty"`
}

// Provider
type Provider struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProviderConfigField defines model for ProviderConfigField.
type ProviderConfigField struct {
	Description string `json:"description"`
	Id          string `json:"id"`

	// Whether the config value is optional.
	IsOptional bool `json:"isOptional"`

	// Whether or not the config field is a secret (like an API key or a password)
	IsSecret bool   `json:"isSecret"`
	Name     string `json:"name"`

	// the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store.
	SecretPath *string `json:"secretPath,omitempty"`
}

// ProviderConfigValue defines model for ProviderConfigValue.
type ProviderConfigValue struct {
	// The ID of the config field.
	Id string `json:"id"`

	// The value entered by the user.
	Value string `json:"value"`
}

// A provider in the process of being set up through the guided setup workflow in Common Fate. These providers are **not** yet active.
type ProviderSetup struct {
	ConfigValidation []externalRef0.ProviderConfigValidation `json:"configValidation"`

	// The current configuration values.
	ConfigValues map[string]string `json:"configValues"`

	// A unique ID for the provider setup. This is a random KSUID to avoid potential conflicts with user-specified provider IDs in the `deployment.yml` file.
	Id string `json:"id"`

	// The status of the setup process.
	Status ProviderSetupStatus `json:"status"`

	// An overview of the steps indicating whether they are complete.
	Steps []ProviderSetupStepOverview `json:"steps"`

	// The type of the Access Provider being set up.
	Type string `json:"type"`

	// The version of the provider.
	Version string `json:"version"`
}

// The status of the setup process.
type ProviderSetupStatus string

// A log entry related to a provider setup validation.
type ProviderSetupDiagnosticLog struct {
	// The log level.
	Level ProviderSetupDiagnosticLogLevel `json:"level"`

	// The log message.
	Msg string `json:"msg"`
}

// The log level.
type ProviderSetupDiagnosticLogLevel string

// ProviderSetupInstructions defines model for ProviderSetupInstructions.
type ProviderSetupInstructions struct {
	StepDetails []ProviderSetupStepDetails `json:"stepDetails"`
}

// ProviderSetupStepDetails defines model for ProviderSetupStepDetails.
type ProviderSetupStepDetails struct {
	ConfigFields []ProviderConfigField `json:"configFields"`
	Instructions string                `json:"instructions"`
	Title        string                `json:"title"`
}

// Indicates whether a setup step is complete or not.
type ProviderSetupStepOverview struct {
	// Whether the step has been completed.
	Complete bool `json:"complete"`
}

// A validation against the configuration values of the Access Provider.
type ProviderSetupValidation struct {
	// The particular config fields validated, if any.
	FieldsValidated []interface{} `json:"fieldsValidated"`

	// The ID of the validation, such as `list-sso-users`.
	Id   string                        `json:"id"`
	Logs *[]ProviderSetupDiagnosticLog `json:"logs,omitempty"`

	// The status of the validation.
	Status ProviderSetupValidationStatus `json:"status"`
}

// The status of the validation.
type ProviderSetupValidationStatus string

// A request to access something made by an end user in Common Fate.
type Request struct {
	AccessRuleId      string `json:"accessRuleId"`
	AccessRuleVersion string `json:"accessRuleVersion"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod `json:"approvalMethod,omitempty"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// Access Rule contains information for an end user to make a request for access.
type RequestAccessRule struct {
	CanRequest  bool   `json:"canRequest"`
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A detailed target for an access rule request
	Target RequestAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// A detailed target for an access rule request
type RequestAccessRuleTarget struct {
	Arguments RequestAccessRuleTarget_Arguments `json:"arguments"`

	// Provider
	Provider Provider `json:"provider"`
}

// RequestAccessRuleTarget_Arguments defines model for RequestAccessRuleTarget.Arguments.
type RequestAccessRuleTarget_Arguments struct {
	AdditionalProperties map[string]RequestArgument `json:"-"`
}

// RequestArgument defines model for RequestArgument.
type RequestArgument struct {
	Description *string                     `json:"description,omitempty"`
	FormElement *RequestArgumentFormElement `json:"formElement,omitempty"`
	Options     []WithOption                `json:"options"`

	// This will be true if a selection is require when creating a request
	RequiresSelection bool   `json:"requiresSelection"`
	Title             string `json:"title"`
}

// RequestArgumentFormElement defines model for RequestArgument.FormElement.
type RequestArgumentFormElement string

// A request to access something made by an end user in Common Fate.
type RequestDetail struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod         `json:"approvalMethod,omitempty"`
	Arguments      RequestDetail_Arguments `json:"arguments"`

	// true if the requesting user is a reviewer of this request.
	CanReview bool `json:"canReview"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// RequestDetail_Arguments defines model for RequestDetail.Arguments.
type RequestDetail_Arguments struct {
	AdditionalProperties map[string]With `json:"-"`
}

// RequestEvent defines model for RequestEvent.
type RequestEvent struct {
	Actor     *string   `json:"actor,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// The current state of the grant.
	FromGrantStatus *RequestEventFromGrantStatus `json:"fromGrantStatus,omitempty"`

	// The status of an Access Request.
	FromStatus         *RequestStatus `json:"fromStatus,omitempty"`
	FromTiming         *RequestTiming `json:"fromTiming,omitempty"`
	GrantCreated       *bool          `json:"grantCreated,omitempty"`
	GrantFailureReason *string        `json:"grantFailureReason,omitempty"`
	Id                 string         `json:"id"`

	// An event which was recorded relating to the grant.
	RecordedEvent  *map[string]string `json:"recordedEvent,omitempty"`
	RequestCreated *bool              `json:"requestCreated,omitempty"`
	RequestId      string             `json:"requestId"`

	// The current state of the grant.
	ToGrantStatus *RequestEventToGrantStatus `json:"toGrantStatus,omitempty"`

	// The status of an Access Request.
	ToStatus *RequestStatus `json:"toStatus,omitempty"`
	ToTiming *RequestTiming `json:"toTiming,omitempty"`
}

// The current state of the grant.
type RequestEventFromGrantStatus string

// The current state of the grant.
type RequestEventToGrantStatus string

// The status of an Access Request.
type RequestStatus string

// RequestTiming defines model for RequestTiming.
type RequestTiming struct {
	DurationSeconds int `json:"durationSeconds"`

	// iso8601 timestamp in UTC timezone
	StartTime *time.Time `json:"startTime,omitempty"`
}

// A decision made on an Access Request.
type ReviewDecision string

// Time configuration for an Access Rule.
type TimeConstraints struct {
	// The maximum duration in seconds the access is allowed for.
	MaxDurationSeconds int `json:"maxDurationSeconds"`
}

// User defines model for User.
type User struct {
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	Groups    []string  `json:"groups"`
	Id        string    `json:"id"`
	LastName  string    `json:"lastName"`
	Picture   string    `json:"picture"`
	Status    IdpStatus `json:"status"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// With defines model for With.
type With struct {
	FieldDescription  *string `json:"fieldDescription,omitempty"`
	Label             string  `json:"label"`
	OptionDescription *string `json:"optionDescription,omitempty"`
	Title             string  `json:"title"`
	Value             string  `json:"value"`
}

// WithOption defines model for WithOption.
type WithOption struct {
	Description *string `json:"description,omitempty"`
	Label       string  `json:"label"`
	Valid       bool    `json:"valid"`
	Value       string  `json:"value"`
}

// AccessTokenResponse defines model for AccessTokenResponse.
type AccessTokenResponse struct {
	HasToken bool    `json:"hasToken"`
	Token    *string `json:"token,omitempty"`
}

// AuthUserResponse defines model for AuthUserResponse.
type AuthUserResponse struct {
	// Whether the user is an administrator of Common Fate.
	IsAdmin bool `json:"isAdmin"`
	User    User `json:"user"`
}

// CompleteProviderSetupResponse defines model for CompleteProviderSetupResponse.
type CompleteProviderSetupResponse struct {
	// Whether a manual update is required to the Common Fate deployment configuration (`deployment.yml`) to activate the provider.
	DeploymentConfigUpdateRequired bool `json:"deploymentConfigUpdateRequired"`
}

// DeploymentVersionResponse defines model for DeploymentVersionResponse.
type DeploymentVersionResponse struct {
	// The deployment version. Will be a semver, such as "v0.9.0" for official releases, or "dev+GIT_HASH" for pre-release builds.
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// IdentityConfigurationResponse defines model for IdentityConfigurationResponse.
type IdentityConfigurationResponse struct {
	AdministratorGroupId string `json:"administratorGroupId"`
	IdentityProvider     string `json:"identityProvider"`
}

// ListAccessRuleApproversResponse defines model for ListAccessRuleApproversResponse.
type ListAccessRuleApproversResponse struct {
	Next  *string  `json:"next"`
	Users []string `json:"users"`
}

// ListAccessRulesDetailResponse defines model for ListAccessRulesDetailResponse.
type ListAccessRulesDetailResponse struct {
	AccessRules []AccessRuleDetail `json:"accessRules"`
	Next        *string            `json:"next"`
}

// ListAccessRulesResponse defines model for ListAccessRulesResponse.
type ListAccessRulesResponse struct {
	AccessRules []AccessRule `json:"accessRules"`
	Next        *string      `json:"next"`
}

// ListFavoritesResponse defines model for ListFavoritesResponse.
type ListFavoritesResponse struct {
	Favorites []Favorite `json:"favorites"`
	Next      *string    `json:"next"`
}

// ListGroupsResponse defines model for ListGroupsResponse.
type ListGroupsResponse struct {
	Groups []Group `json:"groups"`
	Next   *string `json:"next"`
}

// ListProviderSetupsResponse defines model for ListProviderSetupsResponse.
type ListProviderSetupsResponse struct {
	ProviderSetups []ProviderSetup `json:"providerSetups"`
}

// ListRequestEventsResponse defines model for ListRequestEventsResponse.
type ListRequestEventsResponse struct {
	Events []RequestEvent `json:"events"`
	Next   *string        `json:"next"`
}

// ListRequestsResponse defines model for ListRequestsResponse.
type ListRequestsResponse struct {
	Next     *string   `json:"next"`
	Requests []Request `json:"requests"`
}

// ListUserResponse defines model for ListUserResponse.
type ListUserResponse struct {
	Next  *string `json:"next"`
	Users []User  `json:"users"`
}

// A provider in the process of being set up through the guided setup workflow in Common Fate. These providers are **not** yet active.
type ProviderSetupResponse = ProviderSetup

// ReviewResponse defines model for ReviewResponse.
type ReviewResponse struct {
	// A request to access something made by an end user in Common Fate.
	Request *Request `json:"request,omitempty"`
}

// CreateAccessRuleRequest defines model for CreateAccessRuleRequest.
type CreateAccessRuleRequest struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups []string `json:"groups"`
	Name   string   `json:"name"`

	// a request body for creating a Access Rule Target
	Target CreateAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`
}

// CreateFavoriteRequest defines model for CreateFavoriteRequest.
type CreateFavoriteRequest struct {
	AccessRuleId string                       `json:"accessRuleId"`
	Name         string                       `json:"name"`
	Reason       *string                      `json:"reason,omitempty"`
	Timing       RequestTiming                `json:"timing"`
	With         *CreateRequestWithSubRequest `json:"with,omitempty"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	Description *string  `json:"description,omitempty"`
	Members     []string `json:"members"`
	Name        string   `json:"name"`
}

// CreateProviderSetupRequest defines model for CreateProviderSetupRequest.
type CreateProviderSetupRequest struct {
	// The type of the provider to set up.
	ProviderType string `json:"providerType"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	AccessRuleId string                       `json:"accessRuleId"`
	Reason       *string                      `json:"reason,omitempty"`
	Timing       RequestTiming                `json:"timing"`
	With         *CreateRequestWithSubRequest `json:"with,omitempty"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	IsAdmin   bool                `json:"isAdmin"`
	LastName  string              `json:"lastName"`
}

// ProviderSetupStepCompleteRequest defines model for ProviderSetupStepCompleteRequest.
type ProviderSetupStepCompleteRequest struct {
	// Whether the step is complete or not.
	Complete bool `json:"complete"`

	// The config values entered by the user which correspond to the setup step.
	ConfigValues map[string]string `json:"configValues"`
}

// ReviewRequest defines model for ReviewRequest.
type ReviewRequest struct {
	Comment *string `json:"comment,omitempty"`

	// A decision made on an Access Request.
	Decision       ReviewDecision `json:"decision"`
	OverrideTiming *RequestTiming `json:"overrideTiming,omitempty"`
}

// UserAccessRuleLookupParams defines parameters for UserAccessRuleLookup.
type UserAccessRuleLookupParams struct {
	// the provider type i.e. commonfate/aws-sso. type should be encoded i.e.  backslash -> %2
	Type *UserAccessRuleLookupParamsType `form:"type,omitempty" json:"type,omitempty"`

	// the permissionSetArn label, typically resembles a role name i.e. AdminstratorAccess
	PermissionSetArnLabel *string `form:"permissionSetArn.label,omitempty" json:"permissionSetArn.label,omitempty"`

	// the aws account id
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// UserAccessRuleLookupParamsType defines parameters for UserAccessRuleLookup.
type UserAccessRuleLookupParamsType string

// AdminListAccessRulesParams defines parameters for AdminListAccessRules.
type AdminListAccessRulesParams struct {
	// Filter Access Rules by a particular status.
	Status *AdminListAccessRulesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListAccessRulesParamsStatus defines parameters for AdminListAccessRules.
type AdminListAccessRulesParamsStatus string

// AdminListGroupsParams defines parameters for AdminListGroups.
type AdminListGroupsParams struct {
	// encrypted token containing pagination info
	NextToken *string                      `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Source    *AdminListGroupsParamsSource `form:"source,omitempty" json:"source,omitempty"`
}

// AdminListGroupsParamsSource defines parameters for AdminListGroups.
type AdminListGroupsParamsSource string

// AdminListProviderArgOptionsParams defines parameters for AdminListProviderArgOptions.
type AdminListProviderArgOptionsParams struct {
	// invalidate the cache and refresh the provider's options.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// AdminListRequestsParams defines parameters for AdminListRequests.
type AdminListRequestsParams struct {
	// omit this param to view all results
	Status *AdminListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListRequestsParamsStatus defines parameters for AdminListRequests.
type AdminListRequestsParamsStatus string

// AdminGetUsersParams defines parameters for AdminGetUsers.
type AdminGetUsersParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminUpdateUserJSONBody defines parameters for AdminUpdateUser.
type AdminUpdateUserJSONBody struct {
	Groups []string `json:"groups"`
}

// UserListRequestsParams defines parameters for UserListRequests.
type UserListRequestsParams struct {
	// omit this param to view all results
	Status *UserListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// show requests that the user is a reviewer for, rather than requests that the user has made themselves
	Reviewer *bool `form:"reviewer,omitempty" json:"reviewer,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsParamsStatus defines parameters for UserListRequests.
type UserListRequestsParamsStatus string

// UserListRequestsPastParams defines parameters for UserListRequestsPast.
type UserListRequestsPastParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsUpcomingParams defines parameters for UserListRequestsUpcoming.
type UserListRequestsUpcomingParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminCreateAccessRuleJSONRequestBody defines body for AdminCreateAccessRule for application/json ContentType.
type AdminCreateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminUpdateAccessRuleJSONRequestBody defines body for AdminUpdateAccessRule for application/json ContentType.
type AdminUpdateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminCreateGroupJSONRequestBody defines body for AdminCreateGroup for application/json ContentType.
type AdminCreateGroupJSONRequestBody CreateGroupRequest

// AdminUpdateGroupJSONRequestBody defines body for AdminUpdateGroup for application/json ContentType.
type AdminUpdateGroupJSONRequestBody CreateGroupRequest

// AdminCreateProvidersetupJSONRequestBody defines body for AdminCreateProvidersetup for application/json ContentType.
type AdminCreateProvidersetupJSONRequestBody CreateProviderSetupRequest

// AdminSubmitProvidersetupStepJSONRequestBody defines body for AdminSubmitProvidersetupStep for application/json ContentType.
type AdminSubmitProvidersetupStepJSONRequestBody ProviderSetupStepCompleteRequest

// AdminCreateUserJSONRequestBody defines body for AdminCreateUser for application/json ContentType.
type AdminCreateUserJSONRequestBody CreateUserRequest

// AdminUpdateUserJSONRequestBody defines body for AdminUpdateUser for application/json ContentType.
type AdminUpdateUserJSONRequestBody AdminUpdateUserJSONBody

// UserCreateFavoriteJSONRequestBody defines body for UserCreateFavorite for application/json ContentType.
type UserCreateFavoriteJSONRequestBody CreateFavoriteRequest

// UserUpdateFavoriteJSONRequestBody defines body for UserUpdateFavorite for application/json ContentType.
type UserUpdateFavoriteJSONRequestBody CreateFavoriteRequest

// UserCreateRequestJSONRequestBody defines body for UserCreateRequest for application/json ContentType.
type UserCreateRequestJSONRequestBody CreateRequestRequest

// UserReviewRequestJSONRequestBody defines body for UserReviewRequest for application/json ContentType.
type UserReviewRequestJSONRequestBody ReviewRequest

// Getter for additional properties for AccessRuleTargetDetail_With. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetail_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetail_With
func (a *AccessRuleTargetDetail_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a *AccessRuleTargetDetail_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a AccessRuleTargetDetail_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetailArguments_Groupings
func (a *AccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *AccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a AccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTarget_With. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTarget_With) Get(fieldName string) (value CreateAccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTarget_With
func (a *CreateAccessRuleTarget_With) Set(fieldName string, value CreateAccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a *CreateAccessRuleTarget_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal CreateAccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a CreateAccessRuleTarget_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings
func (a *CreateAccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *CreateAccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a CreateAccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRequestWith. Returns the specified
// element and whether it was found
func (a CreateRequestWith) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRequestWith
func (a *CreateRequestWith) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a *CreateRequestWith) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a CreateRequestWith) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestAccessRuleTarget_Arguments. Returns the specified
// element and whether it was found
func (a RequestAccessRuleTarget_Arguments) Get(fieldName string) (value RequestArgument, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestAccessRuleTarget_Arguments
func (a *RequestAccessRuleTarget_Arguments) Set(fieldName string, value RequestArgument) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RequestArgument)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a *RequestAccessRuleTarget_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RequestArgument)
		for fieldName, fieldBuf := range object {
			var fieldVal RequestArgument
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a RequestAccessRuleTarget_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestDetail_Arguments. Returns the specified
// element and whether it was found
func (a RequestDetail_Arguments) Get(fieldName string) (value With, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestDetail_Arguments
func (a *RequestDetail_Arguments) Set(fieldName string, value With) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]With)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a *RequestDetail_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]With)
		for fieldName, fieldBuf := range object {
			var fieldVal With
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a RequestDetail_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Access Rules
	// (GET /api/v1/access-rules)
	UserListAccessRules(w http.ResponseWriter, r *http.Request)
	// Lookup an access rule based on the target
	// (GET /api/v1/access-rules/lookup)
	UserAccessRuleLookup(w http.ResponseWriter, r *http.Request, params UserAccessRuleLookupParams)
	// Get Access Rule
	// (GET /api/v1/access-rules/{ruleId})
	UserGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rule approvers
	// (GET /api/v1/access-rules/{ruleId}/approvers)
	UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rules
	// (GET /api/v1/admin/access-rules)
	AdminListAccessRules(w http.ResponseWriter, r *http.Request, params AdminListAccessRulesParams)
	// Create Access Rule
	// (POST /api/v1/admin/access-rules)
	AdminCreateAccessRule(w http.ResponseWriter, r *http.Request)
	// Get Access Rule
	// (GET /api/v1/admin/access-rules/{ruleId})
	AdminGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update Access Rule
	// (PUT /api/v1/admin/access-rules/{ruleId})
	AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Archive Access Rule
	// (POST /api/v1/admin/access-rules/{ruleId}/archive)
	AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule version history
	// (GET /api/v1/admin/access-rules/{ruleId}/versions)
	AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule Version
	// (GET /api/v1/admin/access-rules/{ruleId}/versions/{version})
	AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request, ruleId string, version string)
	// Get deployment version details
	// (GET /api/v1/admin/deployment/version)
	AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request)
	// List groups
	// (GET /api/v1/admin/groups)
	AdminListGroups(w http.ResponseWriter, r *http.Request, params AdminListGroupsParams)
	// Create Group
	// (POST /api/v1/admin/groups)
	AdminCreateGroup(w http.ResponseWriter, r *http.Request)
	// Delete Group
	// (DELETE /api/v1/admin/groups/{groupId})
	AdminDeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get Group Details
	// (GET /api/v1/admin/groups/{groupId})
	AdminGetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Update Group
	// (PUT /api/v1/admin/groups/{groupId})
	AdminUpdateGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get identity configuration
	// (GET /api/v1/admin/identity)
	AdminIdentityConfiguration(w http.ResponseWriter, r *http.Request)
	// Sync Identity
	// (POST /api/v1/admin/identity/sync)
	AdminIdentitySync(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers)
	AdminListProviders(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers/{providerId})
	AdminGetProvider(w http.ResponseWriter, r *http.Request, providerId string)
	// Get provider arg schema
	// (GET /api/v1/admin/providers/{providerId}/args)
	AdminGetProviderArgs(w http.ResponseWriter, r *http.Request, providerId string)
	// List provider arg options
	// (GET /api/v1/admin/providers/{providerId}/args/{argId}/options)
	AdminListProviderArgOptions(w http.ResponseWriter, r *http.Request, providerId string, argId string, params AdminListProviderArgOptionsParams)
	// List the provider setups in progress
	// (GET /api/v1/admin/providersetups)
	AdminListProvidersetups(w http.ResponseWriter, r *http.Request)
	// Begin the setup process for a new Access Provider
	// (POST /api/v1/admin/providersetups)
	AdminCreateProvidersetup(w http.ResponseWriter, r *http.Request)
	// Delete an in-progress provider setup
	// (DELETE /api/v1/admin/providersetups/{providersetupId})
	AdminDeleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get an in-progress provider setup
	// (GET /api/v1/admin/providersetups/{providersetupId})
	AdminGetProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Complete a ProviderSetup
	// (POST /api/v1/admin/providersetups/{providersetupId}/complete)
	AdminCompleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get the setup instructions for an Access Provider
	// (GET /api/v1/admin/providersetups/{providersetupId}/instructions)
	AdminGetProvidersetupInstructions(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Update the completion status for a Provider setup step
	// (PUT /api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete)
	AdminSubmitProvidersetupStep(w http.ResponseWriter, r *http.Request, providersetupId string, stepIndex int)
	// Validate the configuration for a Provider Setup
	// (POST /api/v1/admin/providersetups/{providersetupId}/validate)
	AdminValidateProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Your GET endpoint
	// (GET /api/v1/admin/requests)
	AdminListRequests(w http.ResponseWriter, r *http.Request, params AdminListRequestsParams)
	// Get a request
	// (GET /api/v1/admin/requests/{requestId})
	AdminGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Returns a list of users
	// (GET /api/v1/admin/users)
	AdminGetUsers(w http.ResponseWriter, r *http.Request, params AdminGetUsersParams)
	// Create User
	// (POST /api/v1/admin/users)
	AdminCreateUser(w http.ResponseWriter, r *http.Request)
	// Update User
	// (POST /api/v1/admin/users/{userId})
	AdminUpdateUser(w http.ResponseWriter, r *http.Request, userId string)
	// ListFavorites
	// (GET /api/v1/favorites)
	UserListFavorites(w http.ResponseWriter, r *http.Request)
	// Create Favorite
	// (POST /api/v1/favorites)
	UserCreateFavorite(w http.ResponseWriter, r *http.Request)

	// (DELETE /api/v1/favorites/{id})
	UserDeleteFavorite(w http.ResponseWriter, r *http.Request, id string)
	// Get Favorite
	// (GET /api/v1/favorites/{id})
	UserGetFavorite(w http.ResponseWriter, r *http.Request, id string)

	// (PUT /api/v1/favorites/{id})
	UserUpdateFavorite(w http.ResponseWriter, r *http.Request, id string)
	// List my requests
	// (GET /api/v1/requests)
	UserListRequests(w http.ResponseWriter, r *http.Request, params UserListRequestsParams)
	// Create a request
	// (POST /api/v1/requests)
	UserCreateRequest(w http.ResponseWriter, r *http.Request)
	// Your GET endpoint
	// (GET /api/v1/requests/past)
	UserListRequestsPast(w http.ResponseWriter, r *http.Request, params UserListRequestsPastParams)
	// Your GET endpoint
	// (GET /api/v1/requests/upcoming)
	UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request, params UserListRequestsUpcomingParams)
	// Get a request
	// (GET /api/v1/requests/{requestId})
	UserGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Instructions
	// (GET /api/v1/requests/{requestId}/access-instructions)
	UserGetAccessInstructions(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Token
	// (GET /api/v1/requests/{requestId}/access-token)
	UserGetAccessToken(w http.ResponseWriter, r *http.Request, requestId string)
	// Cancel a request
	// (POST /api/v1/requests/{requestId}/cancel)
	UserCancelRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// List request events
	// (GET /api/v1/requests/{requestId}/events)
	UserListRequestEvents(w http.ResponseWriter, r *http.Request, requestId string)
	// Review a request
	// (POST /api/v1/requests/{requestId}/review)
	UserReviewRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Revoke an active request
	// (POST /api/v1/requests/{requestid}/revoke)
	UserRevokeRequest(w http.ResponseWriter, r *http.Request, requestid string)
	// Get details for the current user
	// (GET /api/v1/users/me)
	UserGetMe(w http.ResponseWriter, r *http.Request)
	// Get a user
	// (GET /api/v1/users/{userId})
	UserGetUser(w http.ResponseWriter, r *http.Request, userId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// UserListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) UserListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListAccessRules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserAccessRuleLookup operation middleware
func (siw *ServerInterfaceWrapper) UserAccessRuleLookup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserAccessRuleLookupParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionSetArn.label" -------------
	if paramValue := r.URL.Query().Get("permissionSetArn.label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "permissionSetArn.label", r.URL.Query(), &params.PermissionSetArnLabel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionSetArn.label", Err: err})
		return
	}

	// ------------- Optional query parameter "accountId" -------------
	if paramValue := r.URL.Query().Get("accountId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "accountId", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserAccessRuleLookup(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRuleApprovers operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRuleApprovers(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) AdminListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListAccessRulesParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListAccessRules(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateAccessRule(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminArchiveAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminArchiveAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersions(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersion(w, r, ruleId, version)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetDeploymentVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetDeploymentVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListGroups operation middleware
func (siw *ServerInterfaceWrapper) AdminListGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListGroupsParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	// ------------- Optional query parameter "source" -------------
	if paramValue := r.URL.Query().Get("source"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source", r.URL.Query(), &params.Source)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateGroup operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminDeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) AdminDeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminDeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetGroup operation middleware
func (siw *ServerInterfaceWrapper) AdminGetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminIdentityConfiguration operation middleware
func (siw *ServerInterfaceWrapper) AdminIdentityConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminIdentityConfiguration(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminIdentitySync operation middleware
func (siw *ServerInterfaceWrapper) AdminIdentitySync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminIdentitySync(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListProviders operation middleware
func (siw *ServerInterfaceWrapper) AdminListProviders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListProviders(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetProvider operation middleware
func (siw *ServerInterfaceWrapper) AdminGetProvider(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetProvider(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetProviderArgs operation middleware
func (siw *ServerInterfaceWrapper) AdminGetProviderArgs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetProviderArgs(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListProviderArgOptions operation middleware
func (siw *ServerInterfaceWrapper) AdminListProviderArgOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	// ------------- Path parameter "argId" -------------
	var argId string

	err = runtime.BindStyledParameter("simple", false, "argId", chi.URLParam(r, "argId"), &argId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "argId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListProviderArgOptionsParams

	// ------------- Optional query parameter "refresh" -------------
	if paramValue := r.URL.Query().Get("refresh"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListProviderArgOptions(w, r, providerId, argId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListProvidersetups operation middleware
func (siw *ServerInterfaceWrapper) AdminListProvidersetups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListProvidersetups(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateProvidersetup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminDeleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) AdminDeleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminDeleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) AdminGetProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCompleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) AdminCompleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCompleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetProvidersetupInstructions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetProvidersetupInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetProvidersetupInstructions(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminSubmitProvidersetupStep operation middleware
func (siw *ServerInterfaceWrapper) AdminSubmitProvidersetupStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	// ------------- Path parameter "stepIndex" -------------
	var stepIndex int

	err = runtime.BindStyledParameter("simple", false, "stepIndex", chi.URLParam(r, "stepIndex"), &stepIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepIndex", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminSubmitProvidersetupStep(w, r, providersetupId, stepIndex)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminValidateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) AdminValidateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminValidateProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListRequests operation middleware
func (siw *ServerInterfaceWrapper) AdminListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetRequest operation middleware
func (siw *ServerInterfaceWrapper) AdminGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetUsers operation middleware
func (siw *ServerInterfaceWrapper) AdminGetUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminGetUsersParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateUser operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateUser operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListFavorites operation middleware
func (siw *ServerInterfaceWrapper) UserListFavorites(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListFavorites(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateFavorite operation middleware
func (siw *ServerInterfaceWrapper) UserCreateFavorite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateFavorite(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserDeleteFavorite operation middleware
func (siw *ServerInterfaceWrapper) UserDeleteFavorite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserDeleteFavorite(w, r, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetFavorite operation middleware
func (siw *ServerInterfaceWrapper) UserGetFavorite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetFavorite(w, r, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserUpdateFavorite operation middleware
func (siw *ServerInterfaceWrapper) UserUpdateFavorite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserUpdateFavorite(w, r, id)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequests operation middleware
func (siw *ServerInterfaceWrapper) UserListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "reviewer" -------------
	if paramValue := r.URL.Query().Get("reviewer"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "reviewer", r.URL.Query(), &params.Reviewer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reviewer", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCreateRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateRequest(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsPast operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsPast(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsPastParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsPast(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsUpcoming operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsUpcomingParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsUpcoming(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetRequest operation middleware
func (siw *ServerInterfaceWrapper) UserGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessInstructions operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessInstructions(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessToken operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessToken(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCancelRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCancelRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCancelRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestEvents operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestEvents(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserReviewRequest operation middleware
func (siw *ServerInterfaceWrapper) UserReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserReviewRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserRevokeRequest operation middleware
func (siw *ServerInterfaceWrapper) UserRevokeRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestid" -------------
	var requestid string

	err = runtime.BindStyledParameter("simple", false, "requestid", chi.URLParam(r, "requestid"), &requestid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestid", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserRevokeRequest(w, r, requestid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetMe operation middleware
func (siw *ServerInterfaceWrapper) UserGetMe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetMe(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetUser operation middleware
func (siw *ServerInterfaceWrapper) UserGetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules", wrapper.UserListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/lookup", wrapper.UserAccessRuleLookup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}", wrapper.UserGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}/approvers", wrapper.UserGetAccessRuleApprovers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminCreateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminUpdateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/archive", wrapper.AdminArchiveAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions", wrapper.AdminGetAccessRuleVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions/{version}", wrapper.AdminGetAccessRuleVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/deployment/version", wrapper.AdminGetDeploymentVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups", wrapper.AdminListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/groups", wrapper.AdminCreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.AdminDeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.AdminGetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.AdminUpdateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/identity", wrapper.AdminIdentityConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/identity/sync", wrapper.AdminIdentitySync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers", wrapper.AdminListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}", wrapper.AdminGetProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args", wrapper.AdminGetProviderArgs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args/{argId}/options", wrapper.AdminListProviderArgOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups", wrapper.AdminListProvidersetups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups", wrapper.AdminCreateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.AdminDeleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.AdminGetProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/complete", wrapper.AdminCompleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/instructions", wrapper.AdminGetProvidersetupInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete", wrapper.AdminSubmitProvidersetupStep)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/validate", wrapper.AdminValidateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests", wrapper.AdminListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests/{requestId}", wrapper.AdminGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/users", wrapper.AdminGetUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users", wrapper.AdminCreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users/{userId}", wrapper.AdminUpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/favorites", wrapper.UserListFavorites)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/favorites", wrapper.UserCreateFavorite)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/favorites/{id}", wrapper.UserDeleteFavorite)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/favorites/{id}", wrapper.UserGetFavorite)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/favorites/{id}", wrapper.UserUpdateFavorite)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests", wrapper.UserListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests", wrapper.UserCreateRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/past", wrapper.UserListRequestsPast)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/upcoming", wrapper.UserListRequestsUpcoming)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}", wrapper.UserGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-instructions", wrapper.UserGetAccessInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-token", wrapper.UserGetAccessToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/cancel", wrapper.UserCancelRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/events", wrapper.UserListRequestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/review", wrapper.UserReviewRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestid}/revoke", wrapper.UserRevokeRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/me", wrapper.UserGetMe)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/{userId}", wrapper.UserGetUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./accesshandler/openapi.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
